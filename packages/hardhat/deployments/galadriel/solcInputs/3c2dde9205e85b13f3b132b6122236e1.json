{
  "language": "Solidity",
  "sources": {
    "contracts/HateSpeechAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract HateSpeechAgent {\n    string public prompt;\n    string public knowledgeBase;\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct AgentRun {\n        address owner;\n        Message[] messages;\n        uint256 responsesCount;\n        uint8 max_iterations;\n        bool is_finished;\n        uint256 messagesCount;\n    }\n\n    mapping(uint256 => AgentRun) public agentRuns;\n    uint256 private agentRunCount;\n\n    event AgentRunCreated(address indexed owner, uint256 indexed runId);\n    event KnowledgeBaseUpdated(string indexed newKnowledgeBaseCID);\n\n    address private owner;\n    address public oracleAddress;\n\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    IOracle.OpenAiRequest private config;\n\n    constructor(address initialOracleAddress, string memory systemPrompt) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        prompt = systemPrompt;\n\n        config = IOracle.OpenAiRequest({\n            model: \"gpt-4-turbo-preview\",\n            frequencyPenalty: 21, \n            logitBias: \"\", \n            maxTokens: 1000, \n            presencePenalty: 21,\n            responseFormat: '{\"type\":\"text\"}',\n            seed: 0,\n            stop: \"\", \n            temperature: 10, \n            topP: 101, \n            tools: '[{\"type\":\"function\",\"function\":{\"name\":\"web_search\",\"description\":\"Search the internet\",\"parameters\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query\"}},\"required\":[\"query\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"image_generation\",\"description\":\"Generates an image using Dalle-2\",\"parameters\":{\"type\":\"object\",\"properties\":{\"prompt\":{\"type\":\"string\",\"description\":\"Dalle-2 prompt to generate an image\"}},\"required\":[\"prompt\"]}}}]',\n            toolChoice: \"auto\", \n            user: \"\" \n        });\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function setKnowledgeBaseCid(string memory cid) public onlyOwner {\n        require(bytes(cid).length > 0, \"CID cannot be empty\");\n        knowledgeBase = cid;\n        emit KnowledgeBaseUpdated(cid);\n    }\n\n    function runAgent(\n        string memory query,\n        uint8 max_iterations\n    ) public returns (uint256 i) {\n        AgentRun storage run = agentRuns[agentRunCount];\n\n        run.owner = msg.sender;\n        run.is_finished = false;\n        run.responsesCount = 0;\n        run.max_iterations = max_iterations;\n\n        Message memory systemMessage;\n        systemMessage.content = prompt;\n        systemMessage.role = \"system\";\n        run.messages.push(systemMessage);\n        run.messagesCount++;\n\n        Message memory newMessage;\n        newMessage.content = query;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n\n        uint256 currentId = agentRunCount;\n        agentRunCount = agentRunCount + 1;\n\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                query,\n                2\n            );\n            emit AgentRunCreated(run.owner, currentId);\n        } else {\n            IOracle(oracleAddress).createOpenAiLlmCall(currentId, config);\n            emit AgentRunCreated(run.owner, currentId);\n        }\n\n        return currentId;\n    }\n\n    function onOracleOpenAiLlmResponse(\n        uint256 runId,\n        IOracle.OpenAiResponse memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n\n        if (!compareStrings(errorMessage, \"\")) {\n            Message memory newMessage;\n            newMessage.role = \"assistant\";\n            newMessage.content = errorMessage;\n            run.messages.push(newMessage);\n            run.responsesCount++;\n            run.is_finished = true;\n            return;\n        }\n\n        if (run.responsesCount >= run.max_iterations) {\n            run.is_finished = true;\n            return;\n        }\n\n        if (!compareStrings(response.content, \"\")) {\n            Message memory assistantMessage;\n            assistantMessage.content = response.content;\n            assistantMessage.role = \"assistant\";\n            run.messages.push(assistantMessage);\n            run.responsesCount++;\n            run.is_finished = true;\n        }\n\n        if (!compareStrings(response.functionName, \"\")) {\n            IOracle(oracleAddress).createFunctionCall(\n                runId,\n                response.functionName,\n                response.functionArguments\n            );\n            return;\n        }\n\n        run.is_finished = true;\n    }\n\n    function onOracleKnowledgeBaseQueryResponse(\n        uint256 runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n        // Retrieve the last user message\n        require(\n            keccak256(\n                abi.encodePacked(run.messages[run.messagesCount - 1].role)\n            ) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(\n                abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\")\n            );\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint256 i = 0; i < documents.length; i++) {\n            newContent = string(\n                abi.encodePacked(newContent, documents[i], \"\\n\")\n            );\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n        emit AgentRunCreated(run.owner, runId);\n    }\n\n    function onOracleFunctionResponse(\n        uint256 runId,\n        string memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n        require(!run.is_finished, \"Run is finished\");\n        string memory result = response;\n        if (!compareStrings(errorMessage, \"\")) {\n            result = errorMessage;\n        }\n        Message memory newMessage;\n        newMessage.role = \"user\";\n        newMessage.content = result;\n        run.messages.push(newMessage);\n        run.responsesCount++;\n        IOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n    }\n\n    function getMessageHistoryContents(\n        uint256 agentId\n    ) public view returns (string[] memory) {\n        string[] memory messages = new string[](\n            agentRuns[agentId].messages.length\n        );\n        for (uint256 i = 0; i < agentRuns[agentId].messages.length; i++) {\n            messages[i] = agentRuns[agentId].messages[i].content;\n        }\n        return messages;\n    }\n\n    function getMessageHistoryRoles(\n        uint256 agentId\n    ) public view returns (string[] memory) {\n        string[] memory roles = new string[](\n            agentRuns[agentId].messages.length\n        );\n        for (uint256 i = 0; i < agentRuns[agentId].messages.length; i++) {\n            roles[i] = agentRuns[agentId].messages[i].role;\n        }\n        return roles;\n    }\n\n    function isRunFinished(uint256 runId) public view returns (bool) {\n        return agentRuns[runId].is_finished;\n    }\n\n    function compareStrings(\n        string memory a,\n        string memory b\n    ) private pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) ==\n            keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/interfaces/IChatGpt.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"./IOracle.sol\";\n\ninterface IChatGpt {\n    function onOracleFunctionResponse(\n        uint callbackId,\n        string memory response,\n        string memory errorMessage\n    ) external;\n\n    function onOracleLlmResponse(\n        uint callbackId,\n        string memory response,\n        string memory errorMessage\n    ) external;\n\n    function onOracleKnowledgeBaseQueryResponse(\n        uint callbackId,\n        string [] memory documents,\n        string memory errorMessage\n    ) external;\n\n    function getMessageHistory(\n        uint callbackId\n    ) external view returns (IOracle.Message[] memory);\n\n    function getMessageHistoryContents(\n        uint callbackId\n    ) external view returns (string[] memory);\n\n    function getMessageHistoryRoles(\n        uint callbackId\n    ) external view returns (string[] memory);\n\n    function onOracleOpenAiLlmResponse(\n        uint callbackId,\n        IOracle.OpenAiResponse memory response,\n        string memory errorMessage\n    ) external;\n\n    function onOracleGroqLlmResponse(\n        uint callbackId,\n        IOracle.GroqResponse memory response,\n        string memory errorMessage\n    ) external;\n}"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IOracle {\n\n    struct Content {\n        string contentType;\n        string value;\n    }\n\n    struct Message {\n        string role;\n        Content [] content;\n    }\n\n    struct OpenAiRequest {\n        // \"gpt-4-turbo\", \"gpt-4-turbo-preview\" or \"gpt-3.5-turbo-1106\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        // JSON list for tools in OpenAI format, empty for null, names have to match the supported tools\n        string tools;\n        // \"none\", \"auto\" or empty str which defaults to auto on OpenAI side\n        string toolChoice;\n        string user;\n    }\n\n    struct OpenAiResponse {\n        string id;\n\n        // either content is an empty str or functionName and functionArguments\n        string content;\n        string functionName;\n        string functionArguments;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct GroqRequest {\n        // \"llama3-8b-8192\", \"llama3-70b-8192\", \"mixtral-8x7b-32768\" or \"gemma-7b-it\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        string user;\n    }\n\n    struct GroqResponse {\n        string id;\n\n        string content;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct KnowledgeBaseQueryRequest {\n        string cid;\n        string query;\n        uint32 num_documents;\n    }\n\n    function createLlmCall(\n        uint promptId\n    ) external returns (uint);\n\n    function createGroqLlmCall(\n        uint promptId,\n        GroqRequest memory request\n    ) external returns (uint);\n\n    function createOpenAiLlmCall(\n        uint promptId,\n        OpenAiRequest memory request\n    ) external returns (uint);\n\n    function createFunctionCall(\n        uint functionCallbackId,\n        string memory functionType,\n        string memory functionInput\n    ) external returns (uint i);\n\n    function createKnowledgeBaseQuery(\n        uint kbQueryCallbackId,\n        string memory cid,\n        string memory query,\n        uint32 num_documents\n    ) external returns (uint i);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}